# خطة عمل وتوصيات لمشروع EGXpilot

**تاريخ التحديث:** 23 يونيو 2025

بناءً على المراجعة الشاملة، تم إعداد خطة العمل التالية لتنظيم الجهود وتحديد الخطوات القادمة للمشروع.

---

## 1. حصر الملفات غير الضرورية (للتنظيف)

تنظيف المشروع من الملفات الزائدة يحسن من صيانته ويقلل من أي التباس محتمل. القائمة التالية تحتوي على ملفات ومجلدات يُقترح مراجعتها وحذفها أو إضافتها إلى `.gitignore`.

- **ملفات يجب حذفها فورًا:**
    - `config/production.js.backup`: ملف نسخة احتياطية لا حاجة له.
    - `tests/dummy.test.js`: ملف اختبار وهمي.

- **مجلدات وملفات يجب مراجعتها وحذفها (على الأغلب قديمة):**
    - `egxpilot-v2/`: يبدو أنه إصدار قديم وكامل من المشروع. يجب أرشفته وحذفه من الكود الحالي.
    - `docs/Project_Details.md`, `docs/PROJECT_SUMMARY.md`: قد تكون هذه الملفات قديمة وتم استبدالها بالتقرير الشامل الجديد.
    - `ORGANIZATION_REPORT.md`: ملف تقرير قديم على الأرجح.
    - `temp/`: مجلد للملفات المؤقتة، يمكن حذفه.

- **ملفات ومجلدات يجب إضافتها إلى `.gitignore` (إن لم تكن موجودة):**
    - `logs/` و `*.log`: ملفات السجلات (Logs) يتم إنشاؤها أثناء التشغيل ولا يجب أن تكون جزءًا من الكود المصدري.
    - `coverage/`: مجلد تقارير تغطية الاختبارات، يتم إنشاؤه عند تشغيل الاختبارات.
    - `.env*` و `*.env.local`: ملفات البيئة تحتوي على معلومات حساسة ومتغيرات خاصة بكل بيئة عمل.
    - `node_modules/`: (موجود على الأغلب، ولكن للتأكيد).

- **سكربتات للمراجعة (قد تكون لمرة واحدة أو قديمة):**
    - `scripts/`: مراجعة السكربتات الموجودة مثل `populate-*.js`, `test-yahoo-api.js` وتحديد ما إذا كانت لا تزال ضرورية أم يمكن أرشفتها.

---

## 2. قائمة التحسينات المقترحة (Roadmap)

هذه قائمة بالتحسينات التقنية المقترحة، مرتبة حسب الأولوية لضمان بناء منتج قوي ومستقر.

### أولوية قصوى: (أمان واستقرار)
1.  **التحقق من مدخلات الـ API (Input Validation)**: تطبيق مكتبة مثل `joi` أو `express-validator` على جميع الـ endpoints في الخادم الخلفي.
2.  **توحيد شكل استجابة الـ API**: ضمان أن جميع الردود من الـ API تتبع هيكلًا ثابتًا (e.g., `{ success, data, error }`).
3.  **إضافة اختبارات الوحدات (Unit Tests)**: البدء بكتابة اختبارات للمكونات والخدمات الحيوية في الواجهة الأمامية والخلفية باستخدام Jest و React Testing Library.
4.  **إعداد CI/CD Pipeline**: أتمتة عمليات الاختبار والنشر باستخدام أدوات مثل GitHub Actions لضمان جودة الكود.

### أولوية متوسطة: (تجربة المستخدم والأداء)
5.  **تحسين التوافق مع الجوال (Responsiveness)**: مراجعة جميع الصفحات والمكونات للتأكد من أنها تعمل بشكل مثالي على الشاشات الصغيرة.
6.  **تحسين أداء الواجهة الأمامية**: استخدام `React.memo` و `useCallback` لتقليل عمليات إعادة العرض غير الضرورية.
7.  **إضافة ترقيم الصفحات (Pagination)**: للـ Endpoints التي تُرجع قوائم طويلة (مثل قائمة كل الأسهم).
8.  **تحسين معالجة الأخطاء**: توفير رسائل خطأ أكثر تحديدًا ووضوحًا للمستخدم النهائي.

### أولوية منخفضة: (الصيانة والتطوير المستقبلي)
9.  **توثيق الـ API**: إنشاء توثيق تفاعلي باستخدام Swagger/OpenAPI.
10. **تقسيم المكونات الكبيرة**: إعادة هيكلة المكونات الضخمة (مثل `Dashboard`) إلى مكونات أصغر وأكثر قابلية للإدارة.
11. **تحسين إمكانية الوصول (Accessibility)**: تطبيق معايير WCAG لتحسين تجربة الاستخدام لذوي الاحتياجات الخاصة.

---

## 3. استبدال البيانات التجريبية بالبيانات الحقيقية

المشروع يعتمد بشكل كبير على البيانات الحية، ولكن يجب التأكد من عدم وجود أي بيانات ثابتة أو تجريبية متبقية.

- **[ ] مراجعة شاملة للمكونات**: المرور على كل مكون في `frontend/components` والتأكد من أن مصدر بياناته هو hook لجلب البيانات (مثل `useMarketData`) وليس بيانات مكتوبة بشكل ثابت (hardcoded).
- **[ ] التأكد من ديناميكية الرسوم البيانية**: التحقق من أن مكتبة `Recharts` تتلقى بياناتها دائمًا من الـ API.
- **[ ] اختبار جميع وظائف لوحة التحكم**: التأكد من أن `PortfolioTracker`, `TechnicalAnalysis`, `RiskCalculator` تعمل بشكل كامل مع البيانات الحية من الخادم الخلفي.
- **[ ] حذف أي ملفات بيانات وهمية**: البحث عن أي ملفات `json` أو `js` قد تحتوي على بيانات تجريبية في الواجهة الأمامية وحذفها.

---

## 4. خطة توحيد بيئات العمل (Development, Staging, Production)

الهدف هو إنشاء بيئة عمل موحدة باستخدام Docker لتقليل الفجوة بين بيئة التطوير والبيئة الإنتاجية، مما يضمن أن "ما يعمل على جهازي سيعمل في أي مكان".

### المفهوم: بيئة واحدة قابلة للتطوير (Scalable Staging Environment)

سنقوم بإنشاء "بيئة مرحلية" (Staging) تكون نسخة طبق الأصل من البيئة الإنتاجية (Production). هذه البيئة ستُستخدم للاختبار النهائي قبل النشر. بيئة التطوير المحلية ستكون نسخة مصغرة منها.

### خطوات التنفيذ:

1.  **مركزية `docker-compose.yml`**:
    - سنعتمد على ملف `docker-compose.yml` واحد لتعريف جميع الخدمات (backend, frontend, database, redis, nginx).
    - سيتم استخدام متغيرات البيئة (Environment Variables) للتحكم في سلوك الخدمات بين البيئات المختلفة.

2.  **استخدام ملفات `.env` متعددة**:
    - `.env.dev`: يحتوي على إعدادات التطوير (مثل تفعيل Hot-Reloading، كلمات مرور قواعد بيانات محلية).
    - `.env.staging`: يحتوي على إعدادات بيئة الاختبار (مثل الاتصال بقاعدة بيانات الاختبار، استخدام إعدادات مشابهة للإنتاج).
    - `.env.prod`: يحتوي على إعدادات الإنتاج (يتم حقنها بشكل آمن عبر CI/CD secrets).

3.  **تحسين `Dockerfile` للإنتاج**:
    - استخدام **Multi-stage builds** في `Dockerfile` الخاص بالواجهة الأمامية والخلفية.
    - **المرحلة الأولى (Build Stage)**: تثبيت كل الاعتماديات (بما في ذلك `devDependencies`) وبناء التطبيق.
    - **المرحلة الثانية (Final Stage)**: إنشاء صورة Docker خفيفة تحتوي فقط على الملفات النهائية المبنية و `dependencies` الإنتاج، مما يقلل حجم الصورة ويزيد من الأمان.

4.  **إنشاء سكربت موحد للتشغيل**:
    - إنشاء سكربت بسيط (e.g., `run.sh`) يأخذ اسم البيئة كمدخل (`dev` أو `staging`).
    - يقوم السكربت بتحميل ملف `.env` المناسب ثم تشغيل `docker-compose up`.
    - **مثال للتشغيل**: `./run.sh dev` لتشغيل بيئة التطوير، و `./run.sh staging` لتشغيل بيئة الاختبار.

بهذه الطريقة، نضمن أن جميع المطورين يعملون على بيئة متطابقة، وأن ما يتم اختباره في بيئة Staging هو نفسه تمامًا ما سيتم نشره في بيئة Production، مما يقلل بشكل كبير من الأخطاء والمشاكل غير المتوقعة.
